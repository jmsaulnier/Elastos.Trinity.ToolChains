#!/usr/bin/env python

"""
Usage:
./Toolchain/bin/native/build --config ../../my/app/native.trinitynativeconfig.json
    -> Cleans all trinity + dapp
    -> Builds all trinity + dapp
    -> Update runtime config and files to customize the application
./Toolchain/bin/native/trinity-update
    -> Updates trinity with the latest source code

Concept:
- Developers have to build the native app (using this script) only the first time when they don't have any
  native app installed yet on their device, or when they want the latest trinity source code, or when they
  want to deploy their app.
- Developers use the Trinity CLI for efficient development and hot reload.
"""

"""
TRINITY NATIVE CONFIG FILE EXAMPLE:
    {
        "build": {
            "root": "..",
            "out": "../native-out"
        },
        "application": {
            "name": "Elastos DID Demo",
            "packageid": "org.elastos.trinity.dapp.diddemo",
            "icon": "../src/assets/images/logo.png",
            "splashscreen": "../src/assets/images/logo.png",
            "link-prefix": "https://diddemo.trinity-tech.io/",
            "version": {
                "code": 101,
                "name": "1.0.1"
            }
        }
    }
"""

import sys
reload(sys)
sys.setdefaultencoding('utf8')

import argparse
import distutils.dir_util as dir_util
import json
import os
import fnmatch
import platform
import subprocess
import sys
import textwrap
import timeit
import shutil
from collections import OrderedDict
from lxml import etree as et

#####################
### SCRIPT PARAMS ###
#####################

sys.path.append(os.path.abspath(os.path.dirname(os.path.realpath(__file__)) + '/../../lib'))
import ela_plugin

parser = argparse.ArgumentParser(description='Builds the Elastos.Trinity project together with a target dApp in order to generate a native application based on the Trinity runtime.',
                                 formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-c', '--config', dest='native_config_path', metavar='PATH', required=True,
                    help='Trinity native configuration file to customize trinity for the target dApp.')
parser.add_argument('-bv', '--buildvariant', dest='buildvariant', required=False,
                    help='Specify the build variant.')

parser.add_argument('--release', action='store_true', help='Build this project for release.')
parser.add_argument('--buildarg', dest='buildarg', required=False,
                    help='Specify the build arg.')
args = parser.parse_args()

if args.release:
    build_type='--release'
else:
    build_type=''

if args.buildarg:
    build_arg=args.buildarg
else:
    build_arg=''

SCRIPT_PATH=os.path.realpath(__file__)

# Toolchain paths
TOOLCHAINS_DIR_PATH=os.path.dirname(os.path.dirname(os.path.dirname(SCRIPT_PATH)))
TOOLCHAINS_DIR_NAME=os.path.basename(TOOLCHAINS_DIR_PATH)
TRINITY_PROJECT_DIR_PATH=os.path.realpath(os.path.join(TOOLCHAINS_DIR_PATH, ".."))

# Trinity project paths
RUNTIME_DIR_PATH=os.path.join(TRINITY_PROJECT_DIR_PATH, "Runtime")
RUNTIME_COPY_DIR_PATH=os.path.join(TRINITY_PROJECT_DIR_PATH, "RuntimeTmp")
PLUGIN_DIR_PATH=os.path.join(TRINITY_PROJECT_DIR_PATH, "Plugins")

# Paths in Runtime
ANDROID_PLATFORM_SRC_DIR_PATH=os.path.join(RUNTIME_COPY_DIR_PATH, "platform_src/android")
ANDROID_PLATFORM_RES_DIR_PATH=os.path.join(RUNTIME_COPY_DIR_PATH, "platform_res/android")
ANDROID_PLATFORM_DIR_PATH=os.path.join(RUNTIME_COPY_DIR_PATH, "platforms/android")
ANDROID_APP_OUT_DIR_PATH=os.path.join(ANDROID_PLATFORM_DIR_PATH, "app/build/outputs/apk/debug")
BUILT_IN_DIR_PATH=os.path.join(RUNTIME_COPY_DIR_PATH, "www/built-in/")
BUILT_IN_MIRROR_ANDROID=os.path.join(ANDROID_PLATFORM_DIR_PATH, "app/src/main/assets/www/built-in/")
BUILT_IN_MIRROR_IOS=os.path.join(RUNTIME_COPY_DIR_PATH, "platforms/ios/www/built-in/")
BUILT_IN_MIRROR_ELECTRON=os.path.join(RUNTIME_COPY_DIR_PATH, "platforms/electron/www/built-in/")
ELECTRON_TITLEBAR_DIR_PATH=os.path.join(RUNTIME_COPY_DIR_PATH, "platform_src/electron/titlebar")
CONFIG_MIRROR_ANDROID=os.path.join(ANDROID_PLATFORM_DIR_PATH, "app/src/main/assets/www/config/config.json")
CONFIG_MIRROR_IOS=os.path.join(RUNTIME_COPY_DIR_PATH, "platforms/ios/www/config/config.json")

# Paths in dapp
TRINITY_CONFIG_PATH = os.path.realpath(os.path.join(os.getcwd(), args.native_config_path))
TRINITY_CONFIG_DIR_PATH = os.path.dirname(TRINITY_CONFIG_PATH)

###############
### METHODS ###
###############

def run_cmd(cmd, ignore_error=False):
    print("Running: " + cmd)
    ret = subprocess.call(cmd, shell=True)
    if not ignore_error and ret != 0:
        sys.exit(ret)

def remove_tree(directory):
    print("Removing: " + directory)
    if os.path.isdir(directory):
        dir_util.remove_tree(directory)
        # Make sure the deletion was really successful (no file system lock):
        if os.path.exists(directory):
            print("Error: folder could not be totally deleted. Check possible file system lock: "+directory)
            os.exit(1)

def copy_tree(src, dst, clean=True):
    print("Copying " + src + " To " + dst)
    if clean:
        remove_tree(dst)
    print("Copying to: "+dst)
    dir_util.copy_tree(src, dst)

def get_appid(manifest):
    file_in = open(manifest, "r")
    data = json.load(file_in)
    return data['id']

# build app and copy the www/* to Runtime/www/built-in/
def build_app(app_path, platform, needBuild, output="www"):
    print("Building ionic dApp at: "+app_path)

    basename = os.path.basename(app_path)
    print("\r\n-------------------- Building dapp: " + basename + " --------------------")
    os.chdir(app_path)

    if needBuild:
        run_cmd("npm install")
        run_cmd("ionic build --prod")

    app_id = get_appid(app_path +'/src/assets/manifest.json')
    copy_tree(output, BUILT_IN_DIR_PATH + app_id)
    if platform == "all" or platform == "android":
        if os.path.isdir(BUILT_IN_MIRROR_ANDROID):
            copy_tree(output, BUILT_IN_MIRROR_ANDROID + app_id)
    if platform == "all" or platform == "ios":
        if os.path.isdir(BUILT_IN_MIRROR_IOS):
            copy_tree(output, BUILT_IN_MIRROR_IOS + app_id)
    if platform == "all" or platform == "electron":
        if os.path.isdir(BUILT_IN_MIRROR_ELECTRON):
            copy_tree(output, BUILT_IN_MIRROR_ELECTRON + app_id)

# update any kind of json file
def updateJsonFile(jsonfile, key, value):
    file_in = open(jsonfile, "r")
    data = json.load(file_in, object_pairs_hook=OrderedDict)
    file_in.close()

    data[key] = value

    file_out = open(jsonfile, 'w')
    file_out.write(json.dumps(data, indent=4))
    file_out.close()

def updateConfigFile(key, value):
    config_path = os.path.join(RUNTIME_COPY_DIR_PATH, "www/config/config.json")
    updateJsonFile(config_path, key, value)

    # update mirror config file
    if os.path.isfile(CONFIG_MIRROR_ANDROID):
        updateJsonFile(CONFIG_MIRROR_ANDROID, key, value)
    if os.path.isfile(CONFIG_MIRROR_IOS):
        updateJsonFile(CONFIG_MIRROR_IOS, key, value)

def updateConfig():
    # We are building for trinity-native
    updateConfigFile("build.type", "native")

    # Define which dapp to start when trinity starts
    nativePackage = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "packageid", "application/packageid")
    updateConfigFile("native.startup.dapppackage", nativePackage)

    # Enable developer mode to be able to upgrade EPKS - TODO: Should be only when we build for DEBUG!
    updateConfigFile("developer.mode", true)

    if args.buildvariant:
        updateConfigFile("build.variant", args.buildvariant)

# findReplace("some_dir", "find this", "replace with this", "*.txt")
def findReplace(directory, find, replace, filePattern):
    for path, dirs, files in os.walk(os.path.abspath(directory)):
        for filename in fnmatch.filter(files, filePattern):
            filepath = os.path.join(path, filename)
            findReplaceInFile(filepath, find, replace)

def findReplaceInFile(filepath, find, replace):
    with open(filepath) as f:
        s = f.read()
    s = s.replace(find, replace)
    with open(filepath, "w") as f:
        f.write(s)

def runClean():
    os.chdir(TRINITY_PROJECT_DIR_PATH)
    remove_tree("Runtime/platforms")
    remove_tree("Runtime/plugins")

def runClobber():
    print("Starting fresh. Deleting previous build files.")
    os.chdir(TRINITY_PROJECT_DIR_PATH)

    remove_tree("Runtime/node_modules")
    remove_tree("Runtime/origin_platforms")
    remove_tree("Runtime/origin_plugins")
    remove_tree("Runtime/platforms")
    remove_tree("Runtime/plugins")
    remove_tree("Runtime/www")

    remove_tree(RUNTIME_COPY_DIR_PATH)

def loadTrinityNativeConfig():
    if not os.path.isfile(TRINITY_CONFIG_PATH):
        print("Error: No trinity configuration file at "+TRINITY_CONFIG_PATH)
        sys.exit(1)

    print("Loading trinity native config file at "+TRINITY_CONFIG_PATH)

    file_in = open(TRINITY_CONFIG_PATH, "r")
    data = json.load(file_in, object_pairs_hook=OrderedDict)
    file_in.close()
    return data

def buildDApp():
    relativeAppSrcPath = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["build"], "root", "build/root")

    appPath = os.path.realpath(os.path.join(TRINITY_CONFIG_DIR_PATH, relativeAppSrcPath))
    if not os.path.isdir(appPath):
        print("Error: No ionic application at the given root path")
        sys.exit(1)

    build_app(appPath, "all", True, "www")
    #build_app(appPath, "all", False, "www") # TMP

# Returns the folder path in which we will output everything we want to give to the user (dapp developer)
def getOutputDir():
    relativeAppOutPath = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["build"], "out", "build/out")
    if relativeAppOutPath is None:
        print("No output folder defined in the trinity native configuration (build/out)")
        sys.exit(1)

    return os.path.realpath(os.path.join(TRINITY_CONFIG_DIR_PATH, relativeAppOutPath))

def prepareOutputDir():
    outputDir = getOutputDir()
    if not os.path.exists(outputDir):
        os.mkdir(outputDir)

# Copy the generated native APK to user's defined output folder
def copyAPKToOutput():
    apkPath = os.path.realpath(os.path.join(ANDROID_APP_OUT_DIR_PATH, "app-debug.apk"))
    apkOutPath = os.path.realpath(os.path.join(getOutputDir(), "app-debug.apk"))
    shutil.copy2(apkPath, apkOutPath)

    # Make sure the copy was ok
    if not os.path.exists(apkOutPath):
        print("Error: something went wront when trying to copy the android APK file to the output folder")
        sys.exit(1)

def ensureTrinityConfigFieldPresence(dictObject, field, debugHint):
    if not field in dictObject:
        print("Error: No ["+debugHint+"] field defined in the trinity native configuration")
        sys.exit(1)
    return dictObject[field]

# Painful to get for example the "name" element included in a "widget" parent, in case widget is namespaced.
# So we use this helper function. And a self namespace (xmlns instead or xmlns:xxx) on an element shows as None key in its nsmap...
def lxmlGetFirstNamespacedChildByName(parentEL, childName, parentNamespaceName, parentNamespace):
    nsmap = parentEL.nsmap
    nsmap[parentNamespaceName] = parentNamespace
    nsmap.pop(None)
    return parentEL.xpath(parentNamespaceName+":"+childName, namespaces=nsmap)[0]

# Modify the original config.xml file from cordova to adjust it for our new native app
def patchCordovaConfigXml():
    print("Customizing cordova config.xml")
    configXmlPath = os.path.realpath(os.path.join(RUNTIME_COPY_DIR_PATH, "config.xml"))
    tree = et.parse(configXmlPath)

    nativePackage = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "packageid", "application/packageid")

    # Package ID
    print("Patching application package id: "+nativePackage)
    widgetEL = tree.getroot() #<widget>
    widgetEL.attrib["android-packageName"] = nativePackage
    widgetEL.attrib["ios-CFBundleIdentifier"] = nativePackage

    # Application name
    appName = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "name", "application/name")
    print("Patching application name: "+appName)
    nameEL = lxmlGetFirstNamespacedChildByName(widgetEL, "name", "widgets", "http://www.w3.org/ns/widgets")
    nameEL.text = appName

    # Overwrite the config file
    f = open(configXmlPath, 'w')
    f.write(et.tostring(widgetEL, pretty_print=True))
    f.close()

def cloneRuntimeFolder():
    print("Cloning the Runtime folder")
    # TODO: CLONE TO A TMP FOLDER ON THE DEVICE INSTEAD
    copy_tree(RUNTIME_DIR_PATH, RUNTIME_COPY_DIR_PATH)

# Converts package id such as "org.company.app" to "org/company/app"
def androidGetStringifiedFoldersFromPackage():
    nativePackage = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "packageid", "application/packageid")
    return nativePackage.replace(".","/")

def androidPatchPackageIdInSourceCodeBeforeCordovaPrepare():
    nativePackage = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "packageid", "application/packageid")
    stringifiedFoldersFromPath = androidGetStringifiedFoldersFromPackage()
    originalRuntimeSrcFolder = os.path.join(ANDROID_PLATFORM_SRC_DIR_PATH, "app/src/main/java/org/elastos/trinity/runtime")
    renamedRuntimeSrcFolder = os.path.join(ANDROID_PLATFORM_SRC_DIR_PATH, "app/src/main/java/"+androidGetStringifiedFoldersFromPackage())

    # On android, rework source code structure to match package id with the right subfolders
    copy_tree(originalRuntimeSrcFolder, renamedRuntimeSrcFolder)
    remove_tree(originalRuntimeSrcFolder) # delete the original source now that it is duplicated to the new package-based folder

    # Replace all occurences of the original package id with the new package id, in android source files (incl plugins)
    findReplace(ANDROID_PLATFORM_SRC_DIR_PATH, "org.elastos.trinity.runtime", nativePackage, "*.java")
    findReplace(ANDROID_PLATFORM_RES_DIR_PATH, "org.elastos.trinity.runtime", nativePackage, "*.xml") # android layout files

def androidPatchPackageIdInSourceCodeAfterCordovaPrepare():
    nativePackage = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "packageid", "application/packageid")
    findReplace(ANDROID_PLATFORM_DIR_PATH, "org.elastos.trinity.runtime", nativePackage, "*.java")
    findReplace(ANDROID_PLATFORM_DIR_PATH, "org.elastos.trinity.runtime", nativePackage, "*.xml") # Cordova config to access plugins

# Because the app name and package id change, we also need to modify our patch system a bit
def patchCordovaPreparePatches():
    appName = ensureTrinityConfigFieldPresence(TRINITY_NATIVE_CONFIG["application"], "name", "application/name")
    stringifiedPackageNameFoldersFromPath = androidGetStringifiedFoldersFromPackage()

    # modify_xcode_project.js - app name folder is not "elastOS" any more
    modifyXcodeProjectScriptPath = os.path.realpath(os.path.join(RUNTIME_COPY_DIR_PATH, "scripts/modify_xcode_project.js"))
    findReplaceInFile(modifyXcodeProjectScriptPath, "platforms/ios/elastOS.xcodeproj", "platforms/ios/"+appName+".xcodeproj")

    # objc_files.patch - platforms/ios/elastOS is renamed to use the native app name
    objcFilesPatchPath = os.path.realpath(os.path.join(RUNTIME_COPY_DIR_PATH, "scripts/patches/after_platform_add_ios/objc_files.patch"))
    findReplaceInFile(objcFilesPatchPath, "+++ platforms/ios/elastOS", "+++ platforms/ios/"+appName)

    # remove_files.js - app name folder is not "elastOS" any more - android source path has changed too
    removeFilesScriptPath = os.path.realpath(os.path.join(RUNTIME_COPY_DIR_PATH, "scripts/remove_files.js"))
    findReplaceInFile(removeFilesScriptPath, "org/elastos/trinity/runtime", stringifiedPackageNameFoldersFromPath)
    findReplaceInFile(removeFilesScriptPath, "platforms/ios/elastOS", "platforms/ios/"+appName)

####################
### MAIN PROCESS ###
####################

startTime = timeit.default_timer()

# Make sure we are running in the right folder and all necessary files are present
if TOOLCHAINS_DIR_NAME != "ToolChains" or \
   not os.path.isdir(RUNTIME_DIR_PATH):
    print('Error: You should "git clone" the "Elastos.Trinity" project with "--recurse-submodules" option.')
    print('       And run the script within the "ToolChains/bin" directory of the project.')
    sys.exit(1)

# Remove everything - restart totally clean
runClobber()

# Get user's configuration file. This is our link between trinity world and user's dapp world
TRINITY_NATIVE_CONFIG = loadTrinityNativeConfig()

# Make a full copy of the runtime folder as we are going to modify many things, so we will do all
# the work in that copied folder.
cloneRuntimeFolder()

# Patch cordova for our native app config tweaks
patchCordovaConfigXml()

# TODO: patch version code and version name in platform specific files (gradle, plist, etc)

# Rename default "org.elastos.trinity.runtime" related paths to the new app package id
androidPatchPackageIdInSourceCodeBeforeCordovaPrepare()

# Modify the "patch" files themselves
patchCordovaPreparePatches()

# Build the target dApp
buildDApp()

# Update runtime config files
print("Entering temporary Runtime folder at "+RUNTIME_COPY_DIR_PATH)
os.chdir(RUNTIME_COPY_DIR_PATH)
copy_tree("www_files", "www", False)
updateConfig()
ela_plugin.plugin_prepare(True)
""" TMP REMOVED
print("Installing NPM dependencies for the trinity Runtime.")
run_cmd("npm install")
"""
run_cmd("cordova prepare")

# TMP TEST
androidPatchPackageIdInSourceCodeAfterCordovaPrepare()

""" TMP REMOVED ELECTRON - RESTORE THIS BLOCK
# Electron specific preparation step
#ela_plugin.install_electron()
ela_plugin.copy_electron_files()
ela_plugin.install_titlebar()
os.chdir(ELECTRON_TITLEBAR_DIR_PATH)
copy_tree("www", RUNTIME_COPY_DIR_PATH + "/www/shared-titlebar")
os.chdir(RUNTIME_DIR_PATH)
copy_tree("plugin_src", "www/plugin_src")
run_cmd("cordova prepare")
"""

os.chdir(RUNTIME_COPY_DIR_PATH)

# Build the platforms
print("Building platforms")
run_cmd("cordova build android " + build_type + " " + build_arg)
# TMP run_cmd("cordova build electron " + build_type + " " + build_arg)
# TMP run_cmd("cordova build ios " + build_type + " " + build_arg)

# Copy outputs to the target (user defined) output folder
print("Copying generated content to the output folder")
prepareOutputDir()
copyAPKToOutput()

# We are done
print("Native Trinity application generated successfully")

elapsed = timeit.default_timer() - startTime
minutes = elapsed / 60
seconds = elapsed % 60
print('Elapsed time: [%d min %0.2fs]' % (minutes, seconds))
